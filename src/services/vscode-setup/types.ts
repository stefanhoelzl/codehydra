/**
 * Types for VS Code setup service.
 */

/**
 * Configuration for an extension in manifest.json.
 */
export interface ExtensionConfig {
  /** Extension ID in publisher.name format (e.g., "codehydra.sidekick") */
  readonly id: string;
  /** Extension version (e.g., "0.0.1") */
  readonly version: string;
  /** VSIX filename (e.g., "codehydra-sidekick-0.0.1.vsix") */
  readonly vsix: string;
}

/**
 * Structure of manifest.json asset file (generated by build:extensions).
 * This is a flat array of all extensions (local and external).
 */
export type ExtensionsManifest = readonly ExtensionConfig[];

/** Validation result for ExtensionsManifest - success case with strongly typed manifest */
export interface ExtensionsManifestValidationSuccess {
  readonly isValid: true;
  readonly manifest: ExtensionsManifest;
}

/** Validation result for ExtensionsManifest - failure case with error message */
export interface ExtensionsManifestValidationFailure {
  readonly isValid: false;
  readonly error: string;
}

/** Discriminated union for ExtensionsManifest validation result */
export type ExtensionsManifestValidationResult =
  | ExtensionsManifestValidationSuccess
  | ExtensionsManifestValidationFailure;

/**
 * Type guard to validate ExtensionsManifest format.
 * @param value Value to validate
 * @returns Discriminated union with isValid flag - success includes typed manifest, failure includes error message
 */
export function validateExtensionsManifest(value: unknown): ExtensionsManifestValidationResult {
  // New format: manifest.json is a flat array of extension objects
  if (!Array.isArray(value)) {
    return { isValid: false, error: "manifest.json must be an array of extension objects" };
  }

  const extensions: ExtensionConfig[] = [];
  for (let i = 0; i < value.length; i++) {
    const item = value[i];
    if (typeof item === "string") {
      return {
        isValid: false,
        error:
          `manifest.json[${i}] is a string but should be an object with { id, version, vsix }. ` +
          `Found: "${item}". ` +
          `Please update manifest.json to use the new format.`,
      };
    }
    if (typeof item !== "object" || item === null) {
      return {
        isValid: false,
        error: `manifest.json[${i}] must be an object with { id, version, vsix }`,
      };
    }
    const ext = item as Record<string, unknown>;
    if (typeof ext.id !== "string" || !ext.id) {
      return { isValid: false, error: `manifest.json[${i}].id must be a non-empty string` };
    }
    if (typeof ext.version !== "string" || !ext.version) {
      return { isValid: false, error: `manifest.json[${i}].version must be a non-empty string` };
    }
    if (typeof ext.vsix !== "string" || !ext.vsix) {
      return { isValid: false, error: `manifest.json[${i}].vsix must be a non-empty string` };
    }
    extensions.push({ id: ext.id, version: ext.version, vsix: ext.vsix });
  }

  return { isValid: true, manifest: extensions };
}

// ============================================================================
// Preflight Types
// ============================================================================

/** Binary types that can be checked by preflight */
export type BinaryType = "code-server" | "opencode" | "claude";
